---
title: "ECON7333: Assignment 3"
author: "Thomas Doyle"
output:
  pdf_document: default
  html_document: 
    keep_md: yes
editor_options:
  chunk_output_type: inline
---

#### Setup

```{r}
options(scipen=999)
attach(ISLR::Wage)
```

# Exercise 1

## Exercise 1.1

```{r}

loocv_tmse <- function(d){
  #' @d a data.frame returned by `model.frame()`
  #
  n <- dim(d)[1]
  p <- dim(d)[2]
  
  MSE <- rep(0,n)
  
  for(i in 1:n) {
    #
    lm_i <- lm(d[-i,],y=TRUE) # leave i out
    MSE_i <- (lm_i$y[i]-predict(lm_i,d[i,]))^2
    MSE[i] <- MSE_i
  }
  
  return(
    # 
    CV_n <- mean(MSE,na.rm = TRUE)
  )
}

```

## Exercise 1.2

1. $logwage=\beta_0+\beta_1 age$
2. $logwage=\beta_0+\beta_1\;age + \beta_2\; age^2$
3. $logwage=\beta_0+\beta_1\;age + \beta_2\; education$

```{r}
Wage.models <- list(
  model.frame("logwage~age",ISLR::Wage),
  model.frame("logwage~age+I(age^2)",ISLR::Wage),
  model.frame("logwage~age+education",ISLR::Wage)
)
sapply(Wage.models, loocv_tmse)
```

## Exercise 1.3


```{r}

lm.ridge <- function(lambda=0) {
  
  m <- model.frame(logwage~age+education,ISLR::Wage)
  Terms <- attr(eval.parent(m),"terms")
  Y <- model.response(m)
  X <- model.matrix(object = Terms,data = m,contrasts.arg = list(education="contr.treatment"))
  n <- nrow(X)
  p <- ncol(X)
  
  # https://arxiv.org/pdf/1509.09169.pdf
  # Hoerl, A. E. and Kennard, R. W. (1970). 
  ridge.betas <- solve( t(X) %*% X + lambda*diag(p) ) %*% t(X) %*% Y
  
  ## predict Y
  # resid <- (Y-X%*%ridge.betas) 
  # penalty <- lambda*sum(ridge.betas[-1]^2)
  # rss <- sum(resid^2)
  
  l2.norm <- sqrt(sum(ridge.betas[-1]^2)) # drop intercept
  
  return(
    list(
      log.lambda=log(lambda),
      l2.norm=l2.norm,
      coefficients=ridge.betas,
      lambda=lambda
    )
  )
}

```

```{r}
# MLE
lm.ridge.loocv <- function(limits) {
  
  m <- model.frame(logwage~age+education,ISLR::Wage)
  Terms <- attr(eval.parent(m),"terms")
  Y <- model.response(m)
  X <- model.matrix(object = Terms,data = m,contrasts.arg = list(education="contr.treatment"))
  
  loocv <- function(lambda, X, Y, Delta){
    n <- nrow(X)
    p <- ncol(X)
    loss <- 0
    
    for (i in 1:n) {
      loo_beta <- solve(t(X[-i,])%*%X[-i,]+lambda*diag(p))%*%t(X[-i,])%*%Y[-i]
      loss <- loss+(Y[i]-X[i,1]*loo_beta[1]-X[i,-1]%*%loo_beta[-1])^2
    }
    
    return(loss)
  }
  
  # optimize penalty parameter
  # minimize RSS
  opt <- optimize(loocv, limits, X=X, Y=Y)
  l2.norm <- lm.ridge(opt$minimum)$l2.norm
  
  return(
    data.frame(opt,l2.norm)
  )
}

```

Plot $\ln(\lambda)$ against $\ell_2\;\text{norm}$.

```{r}
lambdas <- 100^seq(-2, 5, length = 60)
plot(t(sapply(lambdas,lm.ridge))[,1:2],type="l")

# mle
lm.ridge.loocv(c(10^-10, 10^10))
```


# Exercise 2

```{r}

dgf <- function(n,p) {
  #' @n 
  #' @p
  
  # Initialise
  # 
  b <- rep(0,p)
  b_ <- rep(0,p)
  e <- rep(0.01,n)
  X <- matrix(runif(n*p),n,p)
  y <- 2*X[,1]+4*X[,2]+e
  r <- y
  
  M <- 10
  
  for(m in 1:M) {
    b <- b_
    xj <- X[,which.max(
      apply(X,2,function(X,r) cor(x=X,y=r))
      )]
    a <- e*sign(t(xj)%*%r)
    b <- cbind(b,b + a)
    b_ <- b[,m-1]
    r <- r - a*xj
  }
  
  return(b)
}
dgf(100,5)

```