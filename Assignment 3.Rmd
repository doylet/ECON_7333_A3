---
title: "ECON7333: Assignment 3"
author: "Thomas Doyle"
output:
  pdf_document: default
  html_document: 
    keep_md: yes
editor_options:
  chunk_output_type: inline
---

#### Setup

```{r}
options(scipen=999)
attach(ISLR::Wage)
```

# Exercise 1

## Exercise 1.1

```{r}

loocv_tmse <- function(d){
  #' @d a data.frame returned by `model.frame()`
  #
  n <- dim(d)[1]
  p <- dim(d)[2]
  
  MSE <- rep(0,n)
  
  for(i in 1:n) {
    #
    lm_i <- lm(d[-i,],y=TRUE) # leave i out
    MSE_i <- (lm_i$y[i]-predict(lm_i,d[i,]))^2
    MSE[i] <- MSE_i
  }
  
  return(
    # 
    CV_n <- mean(MSE,na.rm = TRUE)
  )
}

```

## Exercise 1.2

1. $logwage=\beta_0+\beta_1 age$
2. $logwage=\beta_0+\beta_1\;age + \beta_2\; age^2$
3. $logwage=\beta_0+\beta_1\;age + \beta_2\; education$

```{r}
Wage.models <- list(
  model.frame("logwage~age",ISLR::Wage),
  model.frame("logwage~age+I(age^2)",ISLR::Wage),
  model.frame("logwage~age+education",ISLR::Wage)
)
sapply(Wage.models, loocv_tmse)
```

## Exercise 1.3


```{r}

lm.ridge <- function(lambda=0) {
  
  m <- model.frame(logwage~age+education,ISLR::Wage)
  Terms <- attr(eval.parent(m),"terms")
  Y <- model.response(m)
  X <- model.matrix(object = Terms,data = m,contrasts.arg = list(education="contr.treatment"))
  n <- nrow(X)
  p <- ncol(X)
  
  # https://arxiv.org/pdf/1509.09169.pdf
  ridge.fun <- solve(t(X)%*%X+lambda*diag(p))%*%t(X)%*%Y
  penalty <- lambda*sum(ridge.fun[-1]^2)
  
  # predict Y
  Y_ <- X%*%ridge.fun
  resid <- (Y-Y_) 
  rss <- sum(resid^2)
  
  l2.norm <- sqrt(sum(ridge.fun^2))
  
  return(
    list(
      lambda=lambda,
      log.lambda=log(lambda),
      l2.norm=l2.norm,
      obj=rss+penalty,
      rss=rss,
      penalty=penalty,
      coefficients=ridge.fun
    )
  )
}

```

Plot $\ln(\lambda)$ against $\ell_2-norm$.

```{r}
lambdas <- 100^seq(-1, 5, length = 60)
plot(t(sapply(lambdas,lm.ridge))[,2:3],type="l")
```


# Exercise 2

```{r}

dgf <- function(n,p) {
  #' @n 
  #' @p
  
  # Initialise
  # 
  b <- rep(0,p)
  b_ <- rep(0,p)
  e <- rep(0.01,n)
  X <- matrix(runif(n*p),n,p)
  y <- 2*X[,1]+4*X[,2]+e
  r <- y
  
  M <- 10
  
  for(m in 1:M) {
    b <- b_
    xj <- X[,which.max(
      apply(X,2,function(X,r) cor(x=X,y=r))
      )]
    a <- e*sign(t(xj)%*%r)
    b <- cbind(b,b + a)
    b_ <- b[,m-1]
    r <- r - a*xj
  }
  
  return(b)
}
dgf(100,5)

```